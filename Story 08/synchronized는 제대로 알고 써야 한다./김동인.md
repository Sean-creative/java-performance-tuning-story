# Overview

- 서비스를 개발할 때 스레드를 직접 컨트롤할 일이 많지 않다. 서비스의 안정성에 치명적일 수 있기 때문이다.
- 우리가 개발하는 WAS는 여러 개의 스레드가 동작하도록 되어있어 synchronized를 자주 사용한다. 하지만 그렇다고 무조건 안정적이지도 않고 성능에 영향을 끼친다.

# 자바에서 스레드는 어떻게 사용하나?

## 프로세스와 스레드

- 클래스를 하나 수행시키거나 WAS를 기동하면 자바 프로세스가 하나 생성된다.
- 하나의 프로세스인지 여러 프로세스인지는 OS의 프로세스를 조회해보면 된다.
- 하나의 프로세스에는 여러 개의 스레드가 수행된다.
    - 단일 스레드가 생성되어 종료될 수도 있고 여러 개의 스레드가 생성될 수 있다.
- 스레드는 다른 말로 LWP(Lightweight Process)라고도 한다.
    - 프로세스를 만들어 사용하고 있는 메모리를 공유한다.
    - 성능이나 자원 사용에 있어 많은 도움이 된다.

## Thread 클래스 상속과 Runnable 인터페이스 구현

- 스레드의 구현흔 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지가 있다.
    - Thread 클래스는 Runnable 인터페이스를 구현한 것이기 때문에 어느 것을 사용해도 상관없다.
    - 대신 Runnable 인터페이스를 구현하면 원하는 기능을 추가할 수 있다.
        - 장점이기도 하지만 해당 클래스를 수행할 때는 별도의 스레드를 생성해야한다는 단점이 있다.
        - 자바는 다중 상속을 인정하지 않아 어느 클래스를 상속받은 클래스는 Runnable 인터페이스를 구현해야 한다.

## sleep(), wait(), join() 메서드

- 현재 진행중인 스레드를 대기하도록 하기 위해서는 sleep(), wait(), join() 세가지 메서드를 사용한다.
    - wait()
        - Object 클래스에 선언되어있다.
        - 명시된 시간만큼 스레드를 대기시킨다.
        - 아무런 매개변수를 지정하지 않으면 notify() 메서드 혹은 notifyAll() 메서드가 호출될 때까지 대기한다.
    - sleep()
        - 명시된 시간만큼 해당 스레드를 대기시킨다.
        - sleep(long millis) 명시된 ms만큼 해당 스레드가 대기한다. static 메서드이기 때문에 반드시 스레드 객체를 통하지 않아도 사용할 수 있다.
        - sleep(long millis, int nanos) 명시된 ms + 명시된 나노 시간만큼 해당 스레드가 대기한다. 여기서 나노 시간은 0~999999까지 사용할 수 있다. 이 메서드도 위와 마찬가지로 static 메서드이다.
    - join()
        - 명시된 시간만큼 해당 스레드가 죽기를 기다린다.
        - 아무런 매개변수를 지정하지 않으면 죽을때까지 계속 대기한다.
- 세 가지 메서드 모두 예외를 던지도록 되어있어서 사용할 때 반드시 예외처리를 해줘야 한다.

## interrupt(), notify(), notifyAll() 메서드

- 앞선 `sleep()`, `wait()`, `join()` 메서드를 모두 멈출 수 있는 유일한 메서드는 `interrupt()` 메서드이다.
- `interrupt()` 메서드가 호출되면 중지된 스레드에는 `InterruptedException`이 발생한다.
- 제대로 수행되었는지 확인하려면 `interrupted()` 메서드를 호출하거나 `isInterrupted()` 메서드를 호출하면 된다.
- 두 방법의 차이는 `interrupted()` 메서드는 스레드의 상태를 변경시키지만 `isInterrupted()` 메서드는 단지 스레드의 상태만을 리턴한다
- `isAlive()`라는 메서드가 있다. 해당 스레드가 살아있는지 확인하는 메서드다.
- `notify()` 메서드와 `notifyAll()` 메서드는 모두 `wait()` 메서드를 멈추기 위한 메서드다.
    - `wait()` 메서드가 호출된 후 대기 상태를 바뀐 스레드를 깨운다. `notify()` 메서드는 객체의 모니터와 관련있는 단일 스레드를 깨우며 `notifyAll()` 메서드는 객체의 모니터와 관련 있는 모든 스레드를 깨운다.

## interrupt() 메서드는 절대적인 것이 아니다

- interrupt() 메서드를 호출해서 메서드를 중지시키려고 할 때 항상 해당 메서드는 멈추지 않는다.
    - interrupt() 메서드는 해당 스레드가 ‘block’ 되거나 특정 상태에서만 작동한다. 대기 상태일때에만 해당 스레드를 중단시킨다.

# synchronized를 이해하자

- 하나의 객체에 여러 요청이 동시에 들어오면 원하는 처리를 하지 못할 수 있다. 그래서 synchronized를 사용해서 동기화하면 하나의 요청씩 처리하도록 메서드나 블록에서 제어하게 된다.
- syn동기
- 동기화 사용 시점
    - 하나의 객체를 여러 스레드에서 동시에 사용하는 경우
    - static 으로 선언한 객체를 여러 스레드에서 동시에 사용할 경우

```java
public synchronized void sampleMethod() {

}

private Object obj = new Object();
public void sampleBlock() {
	synchronized(obj) {
		// 중간 생략
	}
}
```

# 동기화는 이렇게 사용한다 - 동일 객체 접근 시

- 반드시 필요한 부분에만 동기화를 사용해야 성능 정하를 줄일 수 있다.

# 동기화는 이렇게 사용한다 - static 사용 시

- static을 사용하는 경우에 동기화를 사용한다.

# 동기화를 위해서 자바에서 제공하는 것들

- JDK 5.0부터 java.util.concurrent 가 추가되었다. 이 패키지에서는 주요 개념 네 가지가 있다.
    - Lock: 실행중인 스레드를 간단한 방법으로 정지시켰다가 실행시킨다. 상호참조로 인해 발생하는 데드락을 피할 수 있다.
    - Executors: 스레드를 더 효율적으로 관리할 수 있는 클래스들을 제공한다. 스레드 풀도 제공하므로 필요에 따라 유용하게 사용할 수 있다.
    - Concurrent 콜렉션: 앞서 살펴본 콜렉션의 클래스들을 제공한다.
    - Atomic 변수: 동기화가 되어있는 변수를 제공한다. 이 변수를 사용하면 synchronized 식별자를 메서드에 지정할 필요없이 사용할 수 있다.
    

# JVM 내에서 synchronization은 어떻게 동작할까?

- 자바의 HotSpot VM은 ‘자바 모니터(monitor)’를 제공함으로써 스레드들이 ‘상호 배제 프로토콜(mutual exclusion protocol)’에 참여할 수 있도록 돕는다.
- 자바 모니터는 잠긴 상태(lock)나 풀림(unlocked) 중 하나이며 동일한 모니터에 진입한 여러 스레드들 중에서 한 시점에는 단 하나의 스레드만 모니터를 가질 수 있다.
    - 모니터를 가진 스레드만 모니터에 의해서 보호되는 영역에 들어가서 작업을 할 수 있다.
        - 보호된 영역이란 synchronized로 감싸진 블록을 의미한다.
    - 모니터를 보유한 스레드가 보호 영역에서의 작업을 마치면 모니터는 다른 대기중인 스레드에 넘어간다.
- JDK 5부터는 -XX:+USerBiasedLocking 라는 옵션을 통해서 biased locking이라는 기능을 제공한다.
    - 대부분의 객체들이 하나의 스레드에 의해서 잠기게 되지만 이 옵션을 켜면 스레드가 자기 자신을 향하여 bias된다.
        - 이 상태가 되면 스레드는 많은 비용이 드는 인스트럭션 재배열 작업을 통해서 잠김과 풀림 작업을 수행할 수 있게 된다.
    - 이 작업들은 진보된 적응 스피닝(adaptive spinning) 기술을 사용하여 처리량을 개선시킬 수 있다.
    - 결과적으로 동기화 성능은 보다 빨라졌다.
- HotSpot VM에서 대부분의 동기화 작업은 fast-path 코드 작업을 통해서 진행한다.
- 여러 스레드가 경합을 일으키는 상황이 발생하면 이 fast-path 코드는 slow-path 코드 상태로 변환한다. slow-path 구현은 C++코드로 작성되어있으며 fast-path 코드는 JIT compiler에서 제공하는 장비에 의존적인 코드로 작성되어있다.
