# Collection 인터페이스 구성
 Collection : 가장 상위 인터페이스
 - Set : 중복을 허용하지 않는 집합을 처리하기 위한 인터페이스
 - SortedSet : 오름차순을 갖는 Set 인터페이스
 - List : 순서가 있는 집합을 처리하기 위한 인터페이스이기 때문에 인덱스가 있어 위치를 지정하여 값을 찾을 수 있다. 
   중복을 허용하며, list 인터페이스를 상속받는 클래스 중에 가장 많이 사용하는 것으로 ArrayList가 있다.
 - Queue : 여러 개의 객체를 처리하기 전에 담아서 처리할 떄 사용하기 위한 인터페이스. FIFO
 - Map : Map은 키와 값의 쌍으로 구성된 객체의 집합을 처리하기 위한 인터페이스. 중복되는 키 허용하지 않음
 - SortedMap : 키를 오름차순으로 정렬하는 Map 인터페이스

#Set
 - 중복없는 인터페이스 객체 만들때 유용함
 - HashSet : 데이터를 해쉬 테이블에 담는 클래스로 순서 없이 저장됨
 - TreeSet : red-black 이라는 트리에 데이터를 담으며, 데이터를 담으면서 동시에 정렬을 하기 때문에 HashSet보다 성능상 느림
 - LinkedHashSet : 해쉬 테이블에 데이터를 담는데, 저장된 순서에 따라서 순서가 결정됨.
 
# List
 - 배열의 확장판으로 데이터의 개수를 확실히 모를 때 유용하게 사용된다.
 - Vector : 객체 생성시 크기를 지정할 필요가 없는 배열 클래스
 - ArrayList : Vector와 비슷하지만, 동기화 처리가 되어 있지 않음
 - LinkedList : ArrayList와 동일하지만, Queue 인터페이스를 구현했기 때문에 FIFO 큐 작업 수행

# Map 
 - Key, Value 쌍으로 저장되는 구조체
 - 고유한 값과 그 값을 설명하는 데이터를 보관할 때 유용함
 - HashTable : 데이터를 해쉬 테이블에 담는 클래스. 내부에서 관리하는 해쉬 테이블 객체가 동기화되어 있으므로, 동기화가 필요한 부분에서는 이 클래스 사용 권장
 - HashMap : HashTable 클래스와 다른 점은 null 값을 허용한다는 것과 동기화되어 있지 않다는 것
 - TreeMap : red-black 트리에 데이터를 담으며, TreeSet과 다른점은 키에 의해 순서가 정해짐
 - LinkedHashMap: HashMap과 거의 동일하며 이중연결 리스트라는 방식을 사용하여 데이터를 담음

## List도 순서가 있고 Queue도 순서가 있는데 왜 굳이 Queue가 필요할까?
 -  List의 큰 단점은 데이터가 많은 경우 처리시간이 늘어남. 
 -  데이터가 많으면 많을수록 가장 앞에 있는 데이터를 지우는데 처리하는 시간이 증가하기 때문

## Set 클래스 
 - TreeSet < LinkedHashSet = HashSet
 - 데이터의 크기를 알고 있을 경우에는 객체 생성시 크기를 미리 지정하는 것이 성능상 유리함.
 - 여러 데이터를 넣어 두고 해당 데이터가 존재하는지를 확인하는 용도로 많이 사용됨. Iterator로 가져오는것이 아니라 random하게 가져와야만 한다.

## 속도가 느린 TreeSet은 언제?
 - 데이터를 순서에 따라 탐색할때! (NavigableSet 특정 값보다 큰 값이나 작은 값, 가장 큰 값, 가장 작은 값 등을 추출하는 메서드를 선언해 놓음.

## List 클래스 
 - LinkedList Queue인터페이스 상속받기 때문에 데이터 가져올 때 peek() 메서드 사용
 - ArrayList나 Vector는 실제로 그 안에 배열을 사용하므로 0번째 데이터를 지우면 하나의 값만 옮겨야 하는 것이 아니라 첫 번째부터 마지막에 있는 값까지 위치를 변경한다.

## Map 클래스 
 - 트리형태로 처리하는 Tree Map 클래스가 가장 느림

각 클래스는 용도가 모두 다르며, 필요한 용도에 가장 적합한 클래스를 사용하는 것이 가장 중요하다.

