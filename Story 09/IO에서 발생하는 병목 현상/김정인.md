# 내용정리
---

## 자바의 기본적인 IO 처리 방식
- 자바에서 입력과 출력은 스트림(stream)을 통해서 이루어진다.
- IO 라는 개념은 어떤 디바이스를 통해 이뤄지는 모든 작업을 일컫는다.
- IO 에서 발생하는 시간은 CPU 를 사용하는 시간과 대기 시간 중 대기 시간에 속한다. 따라서 성능상에 커다란 영향을 미친다.

### 바이트 기반의 스트림 입력 처리 클래스
- ByteArrayInputStream : 바이트로 구성된 배열을 읽어서 입력 스트림을 만든다.
- FileInputStream : 이미지와 같은 바이너리 기반의 파일의 스트림을 만든다.
- FilterInputStream : 여러 종류의 유용한 입력 스트림의 추상 클래스이다.
- ObjectInputStream : ObjectOutputStream 을 통해서 저장해 놓은 객체를 읽기 위한 스트림을 만든다.
- PipedInputStream : PipedOutputStream 을 통해서 출력된 스트림을 읽어서 처리하기 위한 스트림을 만든다.
- SequenceInputStream : 별개인 두 개의 스트림을 하나의 스트림으로 만든다.


### Java.io.Reader 의 하위 클래스
- BufferedReader : 문자열 입력 스트림을 버퍼에 담아서 처리한다. 일반적으로 문자열 기반의 파일을 읽을 때 많이 사용한다.
- CharArrayReader : char 의 배열로 된 문자 배열을 처리한다.
- FilterReader : 문자열 기반의 스트림을 처리하기 위한 추상 클래스이다.
- FileReader : 문자열 기반의 파일을 읽기 위한 클래스이다.
- InputStreamReader : 바이트 기반의 스트림을 문자열 기반의 스트림으로 연결하는 역할을 수행한다.
- PipedReader : 파이프 스트림을 읽는다.
- StringReader : 문자열 기반의 소스를 읽는다.


### 성능비교
- FileReader 를 사용할 때 매개변수 없이 read() 메서드를 호출하면, 한줄한줄 읽을 때의 문자열을 리턴하기 때문에 성능이 저하된다.
- read 인자값으로 readBuffer (char []) 을 넘겨주면 해당 배열의 개수만 리턴하기 때문에 성능향상이 된다.
- BufferedReader 클래스는 문자열단위나 문자열 배열단위로 읽을 수 있는 기능을 제공하며, 추가로 라인단위로 읽을 수 있는 readLine() 메서드를 제공한다.
  - 성능상 제일 빠르다.


## IO 병목현상
- Request 마다 특정 파일을 읽어서 호출해야 한다면, IO 작업이 비효율적으로 일어날 확률이 높다.
- 특히 config 파일 같은 경우, init() 메서드에 위치해있어, Request 가 들어올때마다 변경감지를 하는 등의 작업이 수반될 수 있다.
- 이러한 부분을 해결하기 위해 가장 좋은 방법은 데몬 스레드를 하나 생성하여 5분이나 10분에 한번씩 Read 하는 방법이 있다.


## NIO 의 원리

### IO 의 작동원리
1. 개발자가 파일을 읽으라는 메서드를 자바에 전달한다.
2. 파일명을 전달받은 메서드가 운영체제의 커널에게 파일을 읽어 달라고 요청한다.
3. 커널이 하드 디스크로부터 파일을 읽어서 자신의 커널에 있는 버퍼에 복사하는 작업을 수행한다. DMA 에서 이 작업을 수행한다.
4. 자바에서 마음대로 커널의 버퍼를 사용하지 못하므로, JVM 으로 그 데이터를 전달한다.
5. JVM에서 메서드에 있는 스트림 관리 클래스를 사용하여 데이터를 처리한다.

- 자바에서는 3번 복사작업을 할 때에나, 4번 전달 작업을 수행할 때 대기하는 시간이 발생할 수 밖에 없다.
- 이러한 단점을 보완하기 위해 만들어진 것이 NIO 클래스이다.


### NIO
- 버퍼의 도입
- 채널의 도입
- 문자열의 엔코더와 디코더 제공
- Perl 스타일의 정규 표현식에 기초한 패턴 매칭 방법 제공
- 파일을 잠그거나 메모리 매핑이 가능한 파일 인터페이스 제공
- 서버를 위한 복합적인 Non-blocking IO 제공


# 느낀점
---
- IO 병목현상에서 영향력이 큰 부분은 CPU 를 사용하는 시간이 아닌, 대기시간이다.
