# Overview

---

- IO와 NIO의 파일 처리 시 성능상의 비교 결과를 보면서 얼마나 개선할 수 있는지 확인해보자
- NIO는 Non BLocking IO의 약자가 아니라 New IO의 약자이다.

# 기본적인 IO는 이렇게 처리한다

---

- 자바에서 입력과 추력은 스트림(stream)을 통해서 이루어진다.
- IO는 파일 IO 뿐만 아니라 네트워크를 통해서 다른 서버로 데이터를 전송하거나 다른 서버로부터 데이터를 전송 받는 것도 포함한다.
- 간단하게 콘솔에 출력하는 것도 스트림을 통해서 출력하는 것이다.
- IO에서 발생하는 시간은 CPU를 사용하는 시간과 대기 시간 중 대기 시간에 속한다.
- 스트림을 읽는 데 관련된 주요 클래스는 다음과 같다.
    - 명시된 모든 입력과 관련된 스트림은 java.io.InputStream 클래스로부터 상속받았다. 바이트 기반의 스트림 입력을 처리하기 위해서는 이 클래스의 하위 클래스를 사용한다.
        - `ByteArrayInputStream`
            - 바이트로 구성된 배열을 읽어서 입력 스트림을 만든다.
        - `FileInputStream`
            - 이미지와 가은 바이너리 기반의 파일의 스트림을 만든다.
        - `FilterInputStream`
            - 여러 종류의 유용한 입력 스트림의 추상 클래스이다.
        - `ObjectInputStream`
            - ObjectOutputStream을 통해서 저장해 놓은 객체를 읽기 위한 스트림을 만든다.
        - `PipedInputStream`
            - PipedOutputStream을 통해서 출력된 스트림을 읽어서 처리하기 위한 스트림을 만든다.
        - `SequenceInputStream`
            - 별개인 두 개의 스트림을 하나의 스트림으로 만든다.
    - 문자열 기반의 스트림을 읽기 위해서 사용하는 클래스는 java.ioReader 클래스의 하위 클래스다.
        - `BufferedReader`
            - 문자열 입력 스트림을 버퍼에 담아서 처리한다. 일반적으로 문자열 기반의 파일을 읽을 때 가장 많이 사용한다.
        - `CharArrayReader`
            - char의 배열로 된 문자 배열을 처리한다.
        - `FilterReader`
            - 문자열 기반의 스트림을 처리하기 위한 추상 클래승디ㅏ.
        - `FileReader`
            - 문자열 기반의 파일을 읽기 위한 클래스이다.
        - `InputStreamReader`
            - 바이트 기반의 스트림을 문자열 기반의 스트림으로 연결하는 역할을 수행한다.
        - `PipedReader`
            - 파이프 스트림을 읽는다.
        - `StringReader`
            - 문자열 기반의 소스를 읽는다.
- 바이트 단위로 읽거나 문자열 단위로 읽을 때 중요한 것은 한 번 open한 스트림은 반드시 닫아 주어야 한다.
    - 스트림을 닫지 않으면 나중에 리소스가 부족해질 수 있다.
    - 파일을 열지 못하면 관련된 파일을 관리하는 스트림의 상태 변경이 불가능해지기 때문이다.
- 파일을 처리할 때는 되도록이면 `IOException`을 따로 구분하여 처리하는 것이 좋다.
- 문자열 단위로 읽는 것은 비효율적이다. 파일의 크기가 크면 `OutOfMemoryError`가 발생한다.
- `BufferedReader` 클래스는 다른 `FileReader` 클래스와 마찬가지로 문자열 단위나 문자열 배열 단위로 읽을 수 있는 기능을 제공하지만 추가로 라인 단위로 읽을 수 있는 `readLine()` 메서드를 제공한다.

# IO에서 병목이 발생한 사례

---

# 그럼 NIO의 원리는 어떻게 되는 거지?

---

- 근본적으로 IO 작업이 운영체제에서 어떻게 수행되었을까?
    1. 파일을 읽으라는 메서드를 자바에 전달
    2. 파일명을 전달받은 메서드가 운영체제의 커널에게 파일을 읽어 달라고 요청
    3. 커널이 하드 디스크로부터 파일을 읽어서 자신의 커널에 있는 버퍼에 복사하는 작업을 수행. DMA에서 이 작업을 하게 된다.
    4. 자바에서는 커널의 버퍼를 마음대로 사용하지 못하므로 JVM으로 그 데이터를 전달한다.
    5. JVM에서 메서드에 있는 스트림 관리 클래스를 사용하여 데이터를 처리
- 자바에서는 3번 복사 작업을 할 때나 4번 전달 작업을 수행할 때 대기하는 시간이 발생할 수 밖에 없었다.
- JDK 1.4부터 NIO가 생겨났다. 위의 3번 작업을 자바에서 직접 통제하여 시간을 더 단축할 수 있게 한 것이다.
- NIO는 여러가지 개념이 생겨났다.
    - 버퍼의 도입
    - 채널의 도입
    - 문자열의 인코더와 디코더 제공
    - Perl 스타일의 정규 표현식에 기초한 패턴 매칭 방법 제공
    - 파일을 잠그거나 메모리 매핑이 가능한 파일 인터페이스 제공
    - 서버를 위한 복합적인 Non-blocking IO 제공

# DirectByteBuffer를 잘못 사용하여 문제가 발생한 사례

---

- NIO를 사용할 때 ByteBuffer를 사용하는 경우가 있다.
    - `ByteBuffer`는 네트워크나 파일에 있는 데이터를 읽어 들일 때 사용한다.
    - `ByteBuffer`객체를 생성하는 메서드에는 `wrap()`, `allocate()`, `allocateDirect()`가 있다.
        - 자바 JVM에 올려서 사용하는 것이 아니라 OS 메모리에 할당된 메모리를 Native한 JNI로 처리하는 `DirectByteBuffer`객체를 생성한다.
        - GC 상황을 모니터링하기 위해 jstat 명령을 사용해서 확인해볼 수 있다.
            - `DirectByteBuffer`의 생성자는 `reserveMemory()` 메서드를 호출한다. 이 메서드에는 JVM에 할당되어있는 메모리보다 더 많은 메모리를 요구할 경우 `System.gc()` 메서드를 호출하도록 되어있다.
            - `DirectByteBuffer` 객체를 생성할 때는 매우 신중하게 접근해야만 하며 singleton 패턴을 사용하여 JVM에는 하나의 객체만 생성하도록 하는 것을 권장한다.

# lastModified() 메서드의 성능 저하

---

- JDK 6까지는 파일이 변경되어있는지 확인하기 위해 File 클래스에 있는 lastModified() 메서드를 사용해왔다.
- 이 메서드의 처리는 조금 복잡하다.
    - `System.getSecurityManager()` 메서드를 호출하여 `SecurityManager` 객체를 얻어옴
    - 만약 null이 아니면 `SecurityManager` 객체의 `checkRead()` 메서드 수행
    - File 클래스 내부에 있는 `FileSystem`이라는 클래스의 객체에서 `getLastModifiedTime()` 메서드를 수행하여 결과 리턴
    - 이 작업은 IO 작업을 수반하기 때문에 OS의 IO의 영향을 많이 받을 수 밖에 없다.
- JDK 7부터 새로운 개념의 IO 처리를 하기 떄문이다.
    - Path 클래스와 Watch로 시작하는 클래스가 추가되었다. fileWatch() 메서드의 동작은 다음과 같다.
        1. Path 객체를 생성해서 모니터링할 디렉터리를 지정한다.
        2. WatchService 클래스의 watcher라는 객체를 생성한다.
        3. dir이라는 Path 객체의 register라는 메서드를 활용하여 파일이 생성, 수정, 삭제되는 이벤트를 처리하도록 지정하였다.
        4. watch 객체의 take() 메서드를 호출하면 해당 디렉터리에 변경이 있을 때까지 기다리다가 작업이 발견되면 key라는 WatchKey 클래스의 객체가 생성된다. 마치 Socket 관련 객체에 accept() 메서드처럼 어떤 이벤트가 생길때까지 낚시 줄을 던져놓고 기다리고 있는 상황이라고 생각하면 ㅗ딘다.
        5. 파일에 변화가 생겼다면 이벤트의 목록을 가져온다.
        6. 이벤트를 처리한 다음에 key 객체를 reset한다.
    - JDK 7을 사용하는 환경에서 해당 파일이 변경되었는지 주기적으로 확인할 필요가 없어졌다. Watch 관련 클래스만 잘 활용해도 파일을 쉽게 모니터링할 수 있기 때문이다.
