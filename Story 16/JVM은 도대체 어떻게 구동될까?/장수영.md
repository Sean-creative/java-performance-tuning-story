### Hot Spot VM은 어떻게 구성되어 있을까?

---

- 자바를 만든 Sun에서는 자바의 성능을 개선하기 위해서 JIT컴파일러를 만들었고, 이름을 HotSpot으로 지었다.
- 여기서 JIT컴파일러는 프로그램의 성능에 영향을 주는 지점에 대해서 지속적으로 분석한다.
    - 분석된 지점은 부하를 최소화하고 높은 성능을 내기 위한 최적화의 대상이 된다.
- HotSpot은 자바 1.3 버전부터 기본 VM으로 사용되어 왔기 때문에, 지금 운영되고 있는 대부분의 시스템들은 모두 HotSpot 기반의 VM이라고 생각하면 된다.
- HotSpot VM은 세 가지 주요 컴포넌트로 되어있다.
    - VM 런타임
    - JIT 컴파일러
    - 메모리 관리자
- HotSpot VM 아키텍쳐
    - HotSpot VM 런타임에 GC 방식과 JIT컴파일러를 끼워맞춰 사용할 수 있다.
        
        → 이를 위해 VM 런타임은 JIT컴파일러용 API와 가비지 컬렉터용 API를 제공한다.
        
    - JVM을 시작하는 런처와 스레드 관리, JNI등도 VM 런타임에서 제공한다.
    

### JIT Optimizer라는게 도대체 뭘까?

---

- C, C++의 컴파일
    - 먼저 소스코드에서 object 파일을 만들고, 이 object로 수행 가능한 라이브러리로 만든다. 이 작업은 애플리케이션이 수행되는 것과 비교해서 지속, 반복적으로 수행되지 않고 한 번만 수행된다.
- 자바의 컴파일
    - 자바는 자바코드를 바이트코드로 변환한다.
    - 그래서 JVM은 항상 바이트 코드로 시작하며, 동적으로 기계에 의존적인 코드로 변환한다.
    - JIT는 애플리케이션에서 각각의 메서드를 컴파일할 만큼 시간적 여유가 많지 않으므로 모든 코드는 초기에 인터프리터에 의해서 시작되고 → 해당코드가 충분히 많이 사용될 경우에 컴파일할 대상이 된다.
    - HotSpot VM에서 이 작업은 각 메서드에 있는 카운터를 통해서 통제되며, 메서드에는 두개의 카운터가 존재한다
        - 수행카운터 : 메서드를 시작할 때마다 증가
        - 백엣지 카운터 : 높은 바이트코드 인덱스에서 낮은 인덱스로 컨트롤 흐름이 변경될 때마다 증가
            - 메서드가 루프가 존재하는지를 확인할 때 사용되며, 수행카운터보다 컴파일 우선순위가 높다.
        
        → 이 카운터들이 한계치에 도달하면 인터프리터는 컴파일을 요청한다.
        
        - 여기서 수행 카운터에서 사용하는 한계치는 CompileThreshold이며,
        - 백엣지 카운터에서 사용하는 한계치는 CompileThreshold * onStackReplacePercentage / 100 으로 계산한다.
    - 컴파일이 요청되면 → 컴파일 대상 목록의 큐에 쌓이고 → 하나 이상의 컴파일러 스레드가 큐를 모니터링 → 컴파일서 스레드가 바쁘지 않을 때 큐에서 대상을 빼내서 컴파일 시작
        - 보통 인터프리터는 컴파일이 종료되기를 기다리지 않는 대신, 수행 카운터를 리셋하고 인터프리터에서 메서드 수행을 계속한다.
    - 컴파일 종료되면 → 컴파일된 코드와 메서드가 연결되어 메서드가 호출되면 컴파일된 코드를 사용하게 된다.
        - 인터프리터에서 컴파일이 종료될때까지 기다리도록 하려면 JVM 시작시 -Xbatch, -XX:-BackgroundCompilation 옵션을 지정해서 컴파일을 기다리게 할 수도 있다.
    - HotSpot VM은 OSR(On stack Replacement)라는 특별한 컴파일도 수행한다.
        - OSR은 인터프리터에서 수행한 코드 중 오랫동안 루프가 지속되는 경우에 사용된다.
        - 해당 코드의 컴파일이 완료된 상태에서 최적화되지 않은 코드가 수행되고 있는 것을 발견한 경우에 컴파일된 코드로 변경한다.
        - 이 작업은 루프가 끝나지 않고, 지속적으로 수행되고 있을 경우에 큰 도움이 된다.

### JRockit의 JIT 컴파일 및 최적화 절차

---

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bba1def9-f2bc-4347-8097-d877b02b35dc/Untitled.png)

1. JRockit runs JIT compilation
    - 모든 메서드를 컴파일하고 최적화 하는 작업은 JVM시작 시간을 느리게 만들기 때문에 시작할 때는 모든 메서드를 최적화하지는 않는다.
2. JRockit monitors threads
    - sampler thread라는 스레드가 주기적으로 애플리케이션의 스레드를 점검한다.
    - sampler thread는 어떤 스레드가 동작 중인지 여부와 수행내역을 관리하고 이 정보를 통해서  어떤 메서드가 많이 사용되는 지를 확인해서 최적화 대상을 찾는다.
3. JRockit JVM Runs Optimization
    - sampler thread가 식별한 대상을 최적화한다.
    - 이 작업은 백그라운드에서 진행되며 수행중인 애플리케이션에 영향을 주지는 않음

### IBM JVM의 JIT 컴파일 및 최적화 절차

---

- IBM JVM의 JIT 컴파일 방식
    - 인라이닝
        - 메서드가 단순할 때 적용되는 방식
        - 호출된 메서드가 단순할 경우 내용을 호출한 메서드의 코드에 포함해버린다.
        - 장점 : 자주 호출되는 메서드의 성능 향상
    - 지역 최적화
        - 작은 단위의 코드를 분석, 개선
    - 조건 구문 최적화
        - 메서드 내의 조건 구문을 최적화, 효율성을 위해 코드의 수행 경로를 변경
    - 글로벌 최적화
        - 메서드 전체를 최적화 하는 방식
        - 단점 : 컴파일 시간이 많이 소요됨
        - 장점 : 성능개선이 많이 될 수 있음
    - 네이티브 코드 최적화
        - 플랫폼 아키텍쳐에 의존적인 방식
        - 컴파일된 코드는 코드 개시라고 하는 JVM프로세스 영역에 저장된다.
        - 결과적으로 JVM프로세스는 아래 두개로 구분 됨
            - JVM수행 파일
            - 컴파일된 JIT 코드의 집함
            

### JVM이 시작될 때의 절차는 이렇다

---

1. java 명령어 줄에 있는 옵션 파싱
2. 자바 힙 크기 할당 및 JIT 컴파일러 타입 지정
3. CLASSPATH와 LD_LIBRARY_PATH 같은 환경 변수 지정
4. 자바의 Main 클래스가 지정되지 않았으면 Jar 파일의 manifest파일에서 Main클래스를 확인한다.
5. JNI의 표준 API인 JNI_CreateJavaVM을 사용하여 새로 생성한 non-primordial이라는 스레드에서 HotSpot VM을 생성한다.
6. HotSpot VM이 생성되고 초기화되면, Main 클래스가 로딩된 런처에서는 main()메서드 속성 정보를 읽는다.
7. CallStaticVoidMethod는 네이티브 인터페이스를 불러 HotSpot VM에 있는 main() 메서드가 수행된다. 이때 자바 실행 시 Main클래스 뒤에 있는 값들이 전달된다.

### JVM이 종료될 때의 절차는 이렇다.

---

- JVM이 시작할 때 오류가 있어 시작을 중지할 때나, JVM에 심각한 에러가 있어서 중지할 필요가 있을 때는 DestroyJavaVM이라는 메서드를 HotSpot 런처에서 호출한다.
- HotSpot VM의 종료는 다음의 DestroyJavaVM 메서드의 종료 절차를 따른다.
    - HotSpot VM 작동중인 상황에서 단 하나의 데몬이 아닌 스레드가 수행될 떄까지 대기한다.
    - java.lang 패키지에 있는 shutdown클래스의 shutdown()메서드가 수행된다. → 자바 레벨의 shutdown hook이 수행되고 → finalization-on-exit이라는 값이 true일 경우에 자바 객체 finalizer를 수행한다
    - HotSpot VM레벨의 shutdown hook을 수행함으로써 HotSpot VM의 종료를 준비한다.  이 작업은 JVM_OnExit()메서드를 통해서 저장된다. 그리고 HotSpot VM의 스레드들을 종료시킨다 → 이 작업들이 종료되면 JVMTI를 비활성화 하며, signal 스레드를 종료시킨다.

 

### 클래스 로딩 절차도 알고 싶어요?

---

1. 주어진 클래스의 이름으로 클래스 패스에 있는 바이너리로 된 자바 클래스를 찾는다
2. 자바 클래스를 정의한다
3. 해당 클래스를 나타내는 java.lang 패키지의 class 클래스의 객체를 생성한다.
4. 링크 작업이 수행된다 → 이 단계에서 static 필드를 생성 및 초기화하고, 메서드 테이블을 할당한다
5. 클래스의 초기화가 진행되며, 클래스의 static 블록과 static 필드가 가장 먼저 초기화 된다.

### 예외는 JVM에서 어떻게 처리될까?

---

일반적인 예외처리 경우 두가지

1. 예외를 발생한 메서드에서 잡을 경우
2. 호출한 메서드에 의해서 잡힐 경우 
    1. 스택을 뒤져서 적당한 핸들러를 찾는 작업을 필요로 한다.

- VM이 예외가 던져졌다는 것을 알아차렸을 때, 해당 예외를 처리하는 가장 가까운 핸들러를 찾기 위해서 HotSpot VM 런타임 시스템이 수행된다
- 이 때 핸들러를 찾기 위해 현재메서드, 현재 바이트코드, 예외객체 정보가 사용된다
