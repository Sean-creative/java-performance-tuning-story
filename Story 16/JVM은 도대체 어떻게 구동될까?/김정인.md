# 내용정리  

---

- WAS 를 재시작하면 성능이 왜 느릴까?
  - 응답시간이 느려짐
  - CPU 도 많이 씀

<br />


## JVM 은 어떻게 구동될까 ?
- HotSpot VM 의 구조
- JIT 옵티마이저
- JVM 의 구동 절차
- JVM 의 종료 절차
- 클래스 로딩의 절차
- 예외 처리의 절차

<br />

### HotSpot VM은 어떻게 구성되어 있을까?

- HotSpt 의 정확한 명칭은 Java HotSpot Performance Engine 이다.


- JIT 컴파일러는 프로그램의 성능에 영향을 주는 지점에 대해 지속적으로 분석한다.
  - 그 지점은 부하를 최소화하고, 높은 성능을 내기 위한 최적화의 대상이 된다.


- HotSpot VM 의 세가지 주요 컴포넌트
  - VM (Virtual Machine) 런타임
  - JIT (Just In Time) 컴파일러
  - 메모리 관리자


- JIT 컴파일러는 자바 애플리케이션이 수행되는 상황을 보고 동적으로 최적화를 수행한다.


### JIT Optimizer 란?

- JIT 컴파일러는 Client 버전과 Server 버전으로 나뉜다.
- 자바는 Javac 라는 컴파일러를 사용해서 소스코드를 바이트코드로 된 class 라는 파일로 변환함
- JVM 은 항상 바이트 코드로 시작하며, 동적으로 기계에 의존적인 코드로 변환한다.


- JIT 애플리케이션에서 각각의 메서드를 컴파일할 만큼 시간적 여유가 많지 않다.
- 모든 코드는 초기에 인터프리터에 의해서 시작되고, 해당 코드가 충분히 많이 사용될 경우에 컴파일할 대상이 된다.
- HotSpot VM 에서 이 작업은 각 메서드에 있는 카운터를 통해서 통제되며, 메서드에는 두 개의 카운터가 존재한다.
  - 수행 카운터 (invocation counter) : 메서드를 시작할 때마다 증가
  - 백에지 카운터 (backedge counter) : 높은 바이트 코드 인덱스에서 낮은 인덱스로 컨트롤 흐름이 변경될 때마다 증가
    - 백에지 카운터는 메서드가 루프가 존재하는지를 확인할 때 사용되며, 수행 카운터 보다 컴파일 우선순위가 높다.
    - 카운터들이 인터프리터에 의해 증가될 때마다, 그 값들이 한계치에 도달했는지 확인한다.
    - 해당 값이 한계치에 도달하면 인터프리터는 컴파일을 요청한다.
    - 이때의 한계치는 CompileThreshold 이며, 다음 공식으로 계산한다.
      - CompileThreshold * OnStackReplacePercentage / 100
      - XX:CompileThreshold=35000
      - XX:OnStackReplacePercentage=80
      - 35,000 * 80 / 100 = 28,000


### 컴파일 동작 과정

- 컴파일이 요청되면 컴파일 대상 목록의 큐에 쌓인다.
- 하나 이상의 컴파일러 스레드가 이 큐를 모니터링한다.
- 컴파일러 스레드가 바쁘지 않을 때는 큐에서 대상을 빼내서 컴파일을 시작한다.
- 인터프리터는 컴파일이 종료되기를 기다리지 않는 대신, 수행 카운터를 리셋하고 인터프리터에서 메서드 수행을 계속한다.
- 컴파일이 종료되면, 컴파일된 코드와 메서드가 연결되어 그 이후부터는 메서드가 호출되면 컴파일된 코드를 사용한다.
- 인터프리터에서 컴파일이 종료될 때까지 기다리도록 하려면, JVM 시작시 -Xbatch 나 -XX:-BackgroundCompilation 옵션을 지정하여 컴파일을 기다리도록 할 수도 있다.
- HotSpot VM 은 OSR(On Stack Replacement) 이라는 특별한 컴파일도 수행한다.
  - 이 OSR 은 인터프리터에서 수행한 코드 중 오랫동안 루프가 지속되는 경우에 사용된다.
  - 최적화되지 않은 코드가 수행되고 있는 것을 발견한 경우에 인터프리터에 계속 머무르지 않고 컴파일된 코드로 변경한다.
  - 이 작업은 인터프리터에서 시작된 오랫동안 지속되는 루프가 다시는 불리지 않을 경우에 도움이 되지 않지만, 루프가 끝나지 않고 지속적으로 수행되고 있을 경우에는 큰 도움이 된다.

<br />

## JRockit 의 JIT 컴파일 및 최적화 절차

- JVM은 각 OS에서 작동할 수 있도록 자바 코드를 입력 값(바이트코드)으로 받아 각종 변환을 거친 후 해당 칩의 아키텍처에서 잘 돌아가는 기계어 코드로 변환되어 수행되는 구조로 되어있다.

### JRokit runs JIT compilation

- 자바 애플리케이션을 실행하면 기본적으로 JIT 컴파일을 거친 후 실행된다.
- 이 단계를 거친 후 메서드가 수행되면, 그 다음부터는 컴파일된 코드를 호출하기 때문에 처리 성능이 빨라진다.
- 즉, 처음 시작할 때에는 느리지만 그 이후부터는 처리 속도가 훨씬 빨라진다.


- JRockit monitors threads
  - JRockit 에는 sampler thread 라는 스레드가 존재하며, 주기적으로 애플리케이션의 스레드를 점검한다.
  - 이 스레드는 어떤 스레드가 동작 중인지 여부와 수행 내역을 관리한다.
  - 이 정보를 통해서 어떤 메서드가 많이 사용되는지를 확인하여 최적화 대상을 찾는다.

- JRockit JVM Runs Optimization
  - sampler thread 가 식별한 대상을 최적화한다. 
  - 이 작업은 백그라운드에서 진행되며 수행중인 애플리케이션에 영향을 주지 않는다.


## JVM이 시작될 때의 절차
- java 명령어 줄에 있는 옵션 파싱
  - 일부 명령은 자바 실행 프로그램에서 적절한 JIT 컴파일러를 선택하는 등의 작업을 하기 위해 사용하고, 다른 명령들은 HotSpot VM에 전달된다.
- 자바 힙 크기 할당 및 JIT 컴파일러 타입 지정
  - 메모리 크기나 JIT 컴파일러 종류가 명시적으로 지정되지 않은 경우에 자바 실행 프로그램이 시스템의 상황에 맞게 선정된다.
- CLASSPATH 와 LD_LIBRARY_PATH 같은 환경 변수를 지정한다.
- 자바의 Main 클래스가 지정되지 않았으면, Jar 파일의 manifest 파일에서 Main 클래스를 확인한다.
- JNI 의 표준 API 인 JNI_CreateJavaVM을 사용하여 새로 생성한 nonprimordial이라는 스레드에서 HotSpot VM을 생성한다.
- HotSpot VM이 생성되고 초기화되면, Main 클래스가 로딩된 런처에서는 main() 메서드의 속성 정보를 읽는다.
- CallStaticVoidMethod 는 네이티브 인터페이스를 불러 HotSpot VM에 있는 main() 메서드가 수행된다. 이때 자바 실행 시 Main 클래스 뒤에 있는 값들이 전달된다.


## JNI_CreateJavaVM 단계

- JNI_CreateJavaVM 는 동시에 두개의 스레드에서 호출할 수 없고, 오직 하나의 HotSpot VM 인스턴스가 프로세스 내에서 생성될 수 있도록 보장된다.
  - HotSpot VM이 정적인 데이터 구조를 생성하기 때문에 다시 초기화는 불가능하고, 오직 하나의 HotSpot VM이 프로세스에서 생성될 수 있다.
- JNI 버전이 호환성이 있는지 점검하고, GC 로깅을 위한 준비도 완료된다.
- OS 모듈들이 초기화된다. 예를 들면, 랜덤 번호 생성기, PID 할당 등이 여기에 속한다.
- 커멘드 라인 변수와 속성들이 JNI_CreateJavaVM 변수에 전달되고, 나중에 사용하기 위해서 파싱한 후 보관한다.
- 표준 자바 시스템 속성(properties) 이 초기화된다.
- 동기화, 메모리, safepoint 페이지와 같은 모듈들이 초기화된다.
- libzip, libhpi, libjava, libthread와 같은 라이브러리들이 로드된다.
- 시그널 처리기가 초기화 및 설정된다.
- 스레드 라이브러리가 초기화된다.
- 출력(output) 스트림 로거가 초기화된다.
- JVM 을 모니터링하기 위한 에이전트 라이브러리가 설정되어 있으면 초기화 및 시작된다.
- 스레드 처리를 위해서 필요한 스레드 상태와 스레드 로컬 저장소가 초기화 된다.
- HotSpot VM 의 글로벌 데이터들이 초기화된다.
  - 글로벌 데이터에는 이벤트 로그, OS 동기화, 성능 통계 메모리, 메모리 할당자들이 있다.
- HotSpot VM 에서 스레드를 생성할 수 있는 상태가 된다. main 스레드가 생성되고, 현재 OS 스레드에 붙는다. 그러나 아직 스레드 목록에 추가되지는 않는다.
- 자바 레벨의 동기화가 초기화 및 활성화된다.
- 부트 클래스로더, 코드 캐시, 인터프리터, JIT 컴파일러, JNI, 시스템 dictionary, 글로벌 데이터 구조의 집합인 universe 등이 초기화 된다.
- 스레드 목록에 자바 main 스레드가 추가되고, universe 의 상태를 점검한다.
  - HotSpot VMThread 가 여기서 생성된다.
  - 이 시점에 HotSpot VM의 형재 상태를 JVMTI 에 전달한다.
- java.lang 패키지에 있는 String, System, Thread, ThreadGroup, Class 클래스와 java.lang의 하위 패키지에 있는 Method, Finalizer 클래스 등이 로딩되고 초기화된다.
- HotSpt VM의 시그널 핸들러 스레드가 시작되고, JIT 컴파일러가 초기화되며, HotSpot의 컴파일 브로커 스레드가 시작된다.
  - HotSpot VM 과 관련된 각종 스레드들이 시작한다.
  - 이 때 HotSpot VM의 전체 기능이 동작한다.
- JNIEnv 가 시작되며, HotSpot VM 을 시작한 호출자에게 새로운 JNI 요청을 처리할 상황이 되었다고 전달한다.


## JVM 이 종료될 때의 절차는 이렇다.

### HotSpt VM 의 종료는 다음의 DestroyJavaVM 메서드의 종료 절차를 따른다.

- HotSpt VM이 작동중인 상황에서는 단 하나의 데몬이 아닌 스레드가 수행될 때가지 대기한다.
- java.lang 패키지에 있는 Shutdown 클래스의 shutdown() 메서드가 수행된다.
  - 이 메서드가 수행되면 자바 레벨의 shutdown hook 이 수행된다.
  - finalization-on-exit 이라는 값이 true 일 경우에 자바 객체 finalizer 를 수행한다.
- HotSpot VM 레벨의 shutdown hook을 수행함으로써 HotSpot VM 의 종료를 준비한다.
  - 이 작업은 JVM_OnExit() 메서드를 통해서 지정된다.
  - HotSpot VM의 profiler, stat sampler, watcher, garbage collector 스레드를 종료시킨다.
  - 이 작업들이 종료되면 JVMTI를 비활성화하며, Signal 스레드를 종료시킨다.
- HotSpot 의 JavaThread::ext() 메서드를 호추랗여 JNI 처리 블록을 해제한다.
  - 그리고, guaard pages, 스레드 목록에 있는 스레드들을 삭제ㅔ한다.
  - 이 순간부터는 HotSpot VM 에서는 자바 코드를 실행하지 못한다.
- HotSpot VM 스레드를 종료한다.
  - 이 작업을 수행하면 HotSpot VM에 남아있는 HotSpot VM 스레드들을 safepoint 로 옮기고, JIT 컴파일러 스레드들을 종료시킨다.
- JNI, HotSpot VM, JVMTI barrier 에 있는 추적 기능을 종료시킨다.
- 네이티브 스레드에서 수행하고 있는 스레드들을 위해서 HotSpot 의 vm exited 값을 설정한다.
- 현재 스레드를 삭제한다.
- 입출력 스트림을 삭제하고, PerfMemory 리소스 연결을 해제한다.
- JVM 종료를 호출한 호출자로 복귀한다.



## 클래스 로딩 절차

- 주어진 클래스의 이름으로 클래스 패스에 있는 바이너리로 된 자바 클래스를 찾는다.
- 자바 클래스를 정의한다.
- 해당 클래스를 나타내는 java.lang 패키지의 Class 클래스의 객체를 생성한다.
- 링크 작업이 수행된다. 이 단계에서 static 필드를 생성 및 초기화하고, 메서드 테이블을 할당한다.
- 클래스의 초기화가 진행되며, 클래스의 static 블록과 static 필드가가장 먼저 초기화 된다.
  - 해당 클래스가 초기화 되기 전에 부모 클래스의 초기화가 먼저 이루어진다.

- loading -> linking -> linitializing 로 기억하면 된다.


## 예외는 JVM 에서 어떻게 처리될까 ?

- 예외를 발생한 메서드에서 잡을 경우
- 호출한 메서드에 의해서 잡힐 경우


<br />

- 던져진 바이트 코드에 의해서 초기화될 수 있으며,
- VM 내부 호출의 결과로 넘어올 수도 있고,
- JNI 호출로부터 넘어올 수도 있고,
- 자바 호출로부터 넘어올 수 있다.






