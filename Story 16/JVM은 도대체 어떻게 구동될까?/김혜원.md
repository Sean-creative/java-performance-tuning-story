##HotSpot VM은 어떻게 구성되어 있을까?

 - VM 런타임

 - JIT(Just In Time) 컴파일러

 - 메모리 관리자 

 - HotSpot은 자바 1.3 버전부터 기본 VM으로 사용되어 왔기 때문에, 지금 운영되고 있는 대부분의 시스템들은 모두 HotSpot 기반의 VM이라고 생각하면 된다.

 - HotSpot VM은 높은 성능과 확장성을 제공함.

 - HotSpot VM 런타임에 GC방식과 JIT 컴파일러를 끼워 맞춰 사용할 수 있다.

##JIT Optimizer 라는게 도대체 뭘까?

 - c / c++ 의 컴파일

    소스에서 object파일을 만들고,  이 objec로 수행 가능한 라이브러리로 만든다.  이 작업은 애플리케이션이 수행되는 것과 비교해서 지속, 반복적으로 수행되지 않고 한 번만 수행된다. 

 - java

    -Java 컴파일러는 소스코드를 바이트 코드로 된 class라는 파일로 변환해주고, JVM은 항상 바이트 코드로 시작하며, 동적으로 기계에 의존적인 코드로 변환된다.

    - JIT는 애플리케이션에서 각각ㄱ의 메서드를 컴파일할 만큼 시간적 여유가 많이 않아 모든 코드는 초기에 인터프리터에 의해서 시작되고, 해당 코드가 충분히 많이 사용될 경우에 컴파일할 대상이 된다. 

   - HotSpot VM에서 이 작업은 각 메서드에 있는 카운터를 통해서 통제되며, 메서드에는 두개의 카운터가 존재함.

     수행카운터(invocation counter) : 메서드를 시작할 때마다 증가

     백에지 카운터(backedge couter) : 높은 바이트 코드 인덱스에서 낮은 인덱스로 컨트롤 흐름이 변경될 떄마다 증가

  - 백에지 카운터는 메서드가 루프가 존재하는지 확인할 때 사용되며, 수행 카운터 보다 컴파일 우선순위가 높다.

  - 수행 카운터에서 사용하는 한계치는 CompileThreshold이며, 백에지 카운터에서 사용하는 한계치는 다음의 공식으로 계산한다.

 CompileThreshold * OnStackReplacePercentage / 100 

  - 컴파일이 요청되면 컴파일 대상 목록의 큐에 쌓이고 하나 이상의 컴파일러 스레드가 이 큐를 모니터링하고 컴파일러 스레드가 바쁘지 않을 때 큐에서 대상을 빼내서 컴파일 시작

  - 컴파일 종료되면 컴파일된 코드와 메서드가 연결되어 메서드가 호출되면 컴파일된 코드를 사용하게 된다.

## JRockit의 JIT 컴파일 및 최적화 절차

 - JRockit runs JIT compilation

     - JIT를 사용하면 시작할 때의 성능은 느리겠지만, 지속적으로 수행할 때는 더 빠른 처리가 가능하다.

     - 모든 메서드를 컴파일하고 최적화 하는 작업은 JVM시작 시간을 느리게 만들기 때문에 시작할 때는 모든 메서드를 최적화하지는 않는다.

 - JRockit monitors threads
    - sampler thread라는 스레드가 주기적으로 애플리케이션의 스레드를 점검한다.

    - 스레드의 동작 여부와 수행내역을 관리하고 이 정보를 통해서 어떤 메서드가 많이 사용되는 지를 확인해서 최적화 대상을 찾는다.

 - JRockit JVM Runs Optimization

  - sampler thread가 식별한 대상을 최적화한다.

##  IBM JVM의 JIT 컴파일 방식

-인라이닝 : 메서드가 단순할 때 적용되는 방식으로 자주 호출되는 메서드의 성능 향상되는 장점이 있다.

- 지역 최적화 : 작은 단위의 코드를 분석, 개선하는 작업 수행

 - 조건 구문  최적화 : 메서드 내의 조건 구문을 최적화, 효율성을 위해 코드의 수행 경로를 변경

 - 글로벌 최적화 : 메서드 전체를 최적화하는 방식으로 매우 비싼 방식이며, 컴파일 시간이 많이 소요된다. 

                      하지만 성능 개선이 많이 될 수 있다. 

 - 네이티브 코드 최적화 : 아키텍처에 의존적

 - 컴파일된 코드는 ‘코드 캐시’라고 하는 JVM 프로세스 영역에 저장된다. 

## JVM이 시작될 때의 절차는 이렇다

1. java 명령어 줄에 있는 옵션 파싱

2. 자바 힙 크기 할당 및 JIT 컴파일러 타입 지정

3. CLASSPATH와 LD_LIBRARY_PATH 같은 환경 변수 지정

4. 자바의 Main 클래스가 지정되지 않았으면 Jar 파일의 manifest파일에서 Main클래스를 확인한다.

5. JNI의 표준 API인 JNI_CreateJavaVM을 사용하여 새로 생성한 non-primordial이라는 스레드에서 HotSpot VM을 생성한다.

6. HotSpot VM이 생성되고 초기화되면, Main 클래스가 로딩된 런처에서는 main()메서드 속성 정보를 읽는다.

7. CallStaticVoidMethod는 네이티브 인터페이스를 불러 HotSpot VM에 있는 main() 메서드가 수행된다. 이때 자바 실행 시 Main클래스 뒤에 있는 값들이 전달된다.

##JVM이 종료될 때의 절차는 이렇다

1. HotSpot VM이 작동중인 상황에서 단 하나의 데몬이 아닌 스레드(nondaemon thread)가 수행될 때까지 대기한다.

2. java.lang 패키지에 있는 Shutdown 클래스의 shutdown() 메서드가 수행된다. 이 메서드가 수행되면 자바 레벨의 shutdown hook이 수행되고 finalization-on-exit이라는 값이 true일 경우에 자바 객체 finalizer를 수행한다.

3. HotSpot VM 레벨의 shutdown hook을 수행함으로써 HotSpot VM의 종료를 준비한다. 이 작업은 JVM_OnExit() 메서드를 통해서 지정된다. 그리고 HotSpot VM의 profiler, stat sampler, watcher, garbage collector 스레드를 종료시킨다. 이 작업들이 종료되면 JVMTI를 비활성화하며 Signal 스레드를 종료시킨다.

4. HotSpot의 JavaThread::exit() 메서드를 호출하여 JNI 처리 블록을 해제한다. 그리고 guard pages, 스레드 목록에 있는 스레들을 삭제한다. 이 순간부터는 HotSpot VM에서는 자바 코드를 실행하지 못한다.

5. HotSpot VM 스레드를 종료한다. 이 작업을 수행하면 HotSpot VM에 남아있는 HotSpot VM 스레드들을 safepoint로 옮기고 JIT 컴파일러 스레드들을 중지시킨다.

6. JNI, HotSpot VM, JVMTI barrier에 있는 추적(tracing) 기능을 종료시킨다.

7. 네이티브 스레드에서 수행하고 있는 스레드들을 위해서 HotSpot의 “vm exited” 값을 설정한다.

8. 현재 스레드를 삭제한다.

9. 입출력 스트림을 삭제하고 PerfMemory 리소스 연결을 해제한다.

10. JVM 종료를 호출한 호출자로 복귀한다.

##클래스 로딩 절차도 알고 싶어요?

1. 주어진 클래스의 이름으로 클래스 패스에 있는 바이너리로 된 자바 클래스를 찾는다.

2. 자바 클래스를 정의한다.

3. 해당 클래스를 나타내는 java.lang 패키지의 class 클래스의 객체를 생성한다.

4. 링크 작업이 수행된다.  이 단계에서 static 필드를 생성 및 초기화하고, 메서드 테이블을 할당한다.

5. 클래스의 초기화가 진행되며, 클래스의 static 블록과 static 필드가 가장 먼저 초기화 된다.

##예외는 JVM에서 어떻게 처리될까?

 - 일반적인 예외 처리 두가지 경우

 1. 예외를 발생한 메서드에서 잡을 겨우

 2. 호출한 메서드에 의해서 잡힐 경우

- VM이 예외가 던져졌다는 것을 알아차렸을 때, 해당 예외를 처리하는 가장 가까운 핸들러를 찾기 위해서 HotSpot VM 런타임 시스템이 수행되며, 이때 핸들러를 찾기 위해 현재메서드, 현재 바이트 코드 , 예외 객체  정보가 사용된다.
