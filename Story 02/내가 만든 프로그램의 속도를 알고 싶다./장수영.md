# 02. 내가 만든 프로그램의 속도를 알고 싶다.

1. 프로파일링 툴?
    - 시스템의 성능이 느릴 때는 병목지점을 파악하는 작업을 가장 먼저 해야한다.
    - 애플리케이션의 속도에 문제가 있을 때 분석하기 위해 프로파일링 툴, APM툴 등을 사용한다.
    - 프로파일링 툴 = 시스템 문제 분석 툴
    - APM툴과 프로파일링툴 비교
        
        
        | 프로파일링 툴 | APM 툴 |
        | --- | --- |
        | 개발자용 | 운영 환경용 |
        | 소스 레벨의 분석 목적
        느린 메서드, 느린 클래스를 찾는 것이 목적 | 애플리케이션의 장애 상황에 대한 모니터링 및 문제점 진단이 주 목적 |
        | - 애플리케이션의 세부 응답 시간까지 분석 가능
        - 메모리 사용량을 객체나 클래스, 소스의 라인 단위까지 분석 가능 | - 서버의 사용자 수나 리소스에 대한 모니터링
        - 실시간 모니터링을 위한 툴
        - 자바 기반의 클라이언트 프로그램 분석이 불가능 |
        | APM에 비해 저렴 | 프로파일링 툴에 비해 비싸다 |
    - 프로파일링 툴이 기본적으로 제공하는 기능
        - 응답 시간 프로파일링 기능
            
            하나의 클래스 내에서 사용되는 메서드 단위의 응답시간 측정. 보통 CPU시간과 대기시간이 제공된다.
            
        - 메모리 프로파일링
            
            잠깐 사용하고 GC의 대상이 되는 부분을 찾거나, 메모리 부족 현상이 발생하는 부분을 찾는 것이 주된 이유. 클래스 및 메서드 단위의 메모리 사용량이 분석된다.
            
2. System.currentTimeMillis와 System.nanoTime
- 가장 간단하게 프로그램의 속도를 측정할 수 있는 방법
- `static long currentTimeMillis()`
    - 현재 시간을 밀리초로 리턴한다.
    - UTC 기준
    - 1970.1.1부터의 시간을 long타입으로 리턴
    
    ```java
    private DummyData dummy;
    
    public void checkCurrentTimeMillis() {
    	long startTime = System.currentTimeMillis(); // 시작한 밀리초 startTime에 할당
    	dummy = timeMakeObjects(); // 클래스 생성
    	long endTime = System.currentTimeMillis(); // 종료된 시점의 밀리초를 endTime에 할당
    	long elaspedTime = endTime - startTime; // 응답시간 
    }
    ```
    
- `static long nanoTime()`
    - 현재 시간을 나노초로 리턴
    - jdk 5부터 추가
    - `currentTimeMillis()`보다 정확하다. 되도록이면 `nanoTime()`의 결과로 판단하자
    
1. 메서드의 성능을 측정하는 라이브러리
    - JMH
        
        JMH를 사용하면 각 케이스별로 테스트를 수행, 결과 확인가능하다.
        
        결과는 동일하지만 서로 다른 방식의 API에서 제공하는 메서드를 활용할 경우 성능면에서 어떤 차이가 발생하는지 확인하고 싶을 때 사용하면 확실한 차이를 비교할 수 있다.
        
- 성능이 이슈가 되는 사이트의 경우 프로파일링 툴이나 APM 툴을 사용하는 것이 좋다.
