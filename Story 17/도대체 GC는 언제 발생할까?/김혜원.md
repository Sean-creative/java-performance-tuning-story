##GC란?

 - Garbage Collection 말 그대로 쓰레기를 정리하는 작업

## 자바의 Runtime data area는 이렇게 구성된다.

 - PC 레지스터

 - JVM 스택

 - 힙 (heap)

 - 메서드 영역

 - 런타임 상수풀

 - 네이티브 메서드 스택

 - 이 영역 중에서 GC가 발생하는 부분이 바로 힙영역이다.

 - heap 메모리 : 클래스 인스턴스, 배열이 이 메모리에 쌓이며 여러 스레드에서 공유하는 데이터들이 저장되는 메모리이다.

 - non-heap 메모리 : 자바 내부 처리를 위해 필요한 영역이며 주된 영역은 메서드 영역이다. 

   - 메서드 영역 : 모든 JVM 스레드에서 공유한다. 런타임 상수 풀, 필드 정보 데이터가 이 영역에 저장된다.

   - JVM 스택 : 스레드가 시작할 때 JVM 스택이 생성된다. 이 스택에서는 메서드가 호출되는 정보인 프레임이 저장된다. 그리고 지역 변수와 임시 결과, 메서드 수행과 리턴에 관련된 정보도 포함된다.

   - 네이티브 메서드 스택 : 자바 코드가 아닌 다른 언어로 된 코드들이 실행하게 될 때의 스택 정보를 관리한다.

   - PC 레지스터 : 자바의 스레드들은 각자 pc 레지스터를 갖는다. 네이티브한 코드를 제외한 모든 자바 코드들이 수행될 때 JVM의 인스트럭션 주소를 PC 레지스터에 보관한다.

##GC의 원리 

 - GC 작업을 하는 가비지 콜렉터는 다음의 역할을 한다.

   - 메모리 할당

   - 사용 중인 메모리 인식

   - 사용하지 않는 메모리 인식

 - 작업을 수행하지 않으면 할당한 메모리 영역이 꽉 차서 JVM에 Hang이 걸리거나 더 많은 메모리를 할당하려고 하여 문제가 생긴다. JVM의 최대 메모리 크기를 지정해서 전부 사용하고 GC를 해도 더 이상 사용 가능한 메모리 영역이 없는데 계속 메모리를 할당하려고 하면 OutOfMemoryError가 발생하여 JVM이 다운될 수 있다.

##GC의 종류

- 마이너 GC: Young 영역에서 발생하는 GC

- 메이저 GC: Old 영역이나 Perm 영역에서 발생하는 GC

 - gc가 발생하거나 객체가 각 영역에서 다른 영역으로 이동할때 애플리케이션의 병목이 발생하면서 성능에 영향을 미친다. 그래서 핫스팟 JVM에서는 스레드 로컬 할당 버퍼라는 것을 사용해 각 스레드별 메모리 버퍼를 사용하면 다른 스레드에 영향을 주지 않는 메모리 할당 작업이 가능해진다.

##5가지 GC방식 

 - Serial Collector

 - Parallel Collector

 - Parallel Compacting Collector

 - Concurrent Mark-Sweep (CMS) Collector

 - Garbage First Collector

##강제로 GC시키기

 - System.gc() ``Runtime.getRuntime().gc() 사용으로 GC발생시킬 수 있다.

 - 웹 기반 시스템에서는 권장 하지 않음.
